# #
# # answer = 0
# # 50.times do |n|
# #   answer = answer + ((n+1) ** 4)
# # end

# # p answer

# #約数

# # def divisor(num)
# #   result = []
# #   i = 1
# #   while i <= num do
# #     remainder = num % i
# #     if remainder == 0
# #       result << i
# #     end
# #     i += 1
# #   end
# #   return result
# # end

# # array = divisor(1234567890)
# # # p array
# # # def method(array)
# # #  array.map{|n|
# # #   if n < 5
# # #     n
# # #   end
# # # }
# # # end

# # p array.map{|n|
# #   if n <= 20000000
# #     n
# #   end
# # }.compact.sum

# #三問目

# # 整数Nについて、1からNまでの整数の逆数の和を「Nまでの逆数和」と呼ぶことにします。

# # 1までの逆数和 = 1/1 = 1
# # 2までの逆数和 = 1/1 + 1/2 = 1.5
# # 3までの逆数和 = 1/1 + 1/2 + 1/3 = 1.8333333333…
# # 4までの逆数和 = 1/1 + 1/2 + 1/3 + 1/4 = 2.0833333333…
# # Nまでの逆数和が8を超えるような最小のNを求めてください。
# # i = 1.0
# # answer = 0
# # number = 0
# # number = number.to_f
# # while number < 8 do
# #   number = number + ( 1 / i ).to_f
# #   i += 1
# #   p number
# # end
# #  p number
# #  p i

# # # 四問目
# # 3の倍数と3のつく数字だけ
# # 次の条件の少なくとも一方を満たす整数のことを「A的な数」と呼ぶことにします。

# # 3の倍数である。
# # 十進法で書いた場合に「3」が含まれる。
# # 例えば、9、31、42、135は何れも「A的な数」です。

# # 1から30000までの整数のうち「A的な数」だけを足し合わせたときの合計を求めてください。
# # answer = 0
# # 30000.times do |n|
# #   if (n + 1) % 3 == 0 or (n+1).to_s.include?("3")
# #     answer += ( n + 1 )
# #   end
# # end

# # p answer

# #5問目

# num = 141592653589793238462643383279502884197169399375105820974944592307816406286208998628034825342117067982148086513282306647093844609550582231725359408128481117450284102701938521105559644622948954930381964428810975665933446128475648233786783165271201909145648566923460348610454326648213393607260249141273724587006606315588174881520920962829254091715364367892590360011330530548820466521384146951941511609433057270365759591953092186117381932611793105118548074462379962749567351885752724891227938183011949129833673362440656643086021394946395224737190702179860943702770539217176293176752384674818467669405132000568127145263560827785771342757789609173637178721468440901224953430146549585371050792279689258923542019956112129021960864034418159813629774771309960518707211349999998372978049951059731732816096318595024459455346908302642522308253344685035261931188171010003137838752886587533208381420617177669147303

# # array.to_s
# # p array.to_s.split("")
# # p num.to_s.split("").length
# array = num.to_s.split("")
# # p array
# answers = []
# 899.times do |n|
#   answers << "#{array[n]}" + "#{array[n + 1]}"
# end

# # p answers
# p answers.group_by(&:itself).map{|k, v| [k, v.size]}.sort_by{|k, v| -v}.to_h

#6

# 2から1000000までの整数を以下の規則に従ってソート（整列）をします。

# 「1以外の最小の約数」が大きい順に並べる。例えば、143（約数は11）は147（約数は3）よりも前になる。
# 「1以外の最小の約数」が同じ場合は、その数自身が大きい順に並べる。例えば、119（約数は7）は91（約数は7）よりも前になる。
# この規則でソートした場合、先頭から250001番目にある整数（先頭は“1番目”と数えます）は何かを求めてください。


array = [2..1000000]

def divisor(num)
  result = []
  i = 1
  while i <= num do
    remainder = num % i
    if remainder == 0
      result << i
    end
    i += 1
  end
  return result
end

# p divisor(10).max


10.times do |n|
  p divisor(n)
  p divisor(n).max
end

